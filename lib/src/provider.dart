// Generated by Dart Safe Data Class Generator. * Change this header on extension settings *
// ignore_for_file: type=lint
import 'package:context_plus/context_plus.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter/widgets.dart';

typedef Create<T> = T Function(BuildContext context);

class Provider<T> extends ProviderWidget {
  const Provider({
    required this.create,
    this.ref,
    this.lazy,
    this.dispose,
    super.key,
    super.child,
    super.builder,
  });

  /// The [Ref] to use. If null, a new [Ref] is created with this [T] type.
  final Ref<T>? ref;

  /// Whether to create the value only when it's first called.
  final bool? lazy;

  /// How to create the value.
  final Create<T> create;

  /// How to dispose the value.
  final void Function(BuildContext context, T value)? dispose;

  /// A static method to get the value of this provider.
  static T of<T>(BuildContext context, {bool listen = true}) {
    final value = _ProviderPlus.of(context)?.get<T>(context, listen: listen);

    if (value is! T) {
      throw Exception('A provider for $T unexpectedly returned $value.');
    }

    return value;
  }

  static Widget root({
    Key? key,
    List<ContextWatcher<Object>> additionalWatchers = const [],
    required Widget child,
  }) =>
      _ProviderPlus(additionalWatchers: additionalWatchers, child: child);

  @override
  void bind(BuildContext context) {
    final ref = this.ref ?? _ProviderPlus.of(context)!.ref<T>(context);

    ref.bindLazy(
      key: key,
      context,
      () => create(context),
      dispose: dispose != null ? (v) => dispose!(context, v) : null,
    );

    if (lazy == false) ref.of(context);
  }
}

class MultiProvider extends ProviderWidget {
  const MultiProvider({
    super.key,
    required this.providers,
    super.builder,
    super.child,
  });
  final List<ProviderWidget> providers;

  @override
  void bind(BuildContext context) {
    for (final provider in providers) {
      provider.bind(context);
    }
  }
}

/// A widget that can bind a [Ref] to a [BuildContext].
///
/// Typically extended by [Provider] and [MultiProvider].
abstract class ProviderWidget extends StatelessWidget {
  const ProviderWidget({super.key, this.builder, this.child});

  /// The builder with the [BuildContext] and the [child] widget.
  final TransitionBuilder? builder;

  /// The child widget.
  final Widget? child;

  /// Binds the [Ref] to the [BuildContext].
  void bind(BuildContext context);

  @override
  Widget build(BuildContext context) {
    assert(builder != null || child != null);

    if (_ProviderPlus.of(context) == null) {
      return _ProviderPlus(child: Builder(builder: build));
    }

    bind(context);

    return builder?.call(context, child) ?? child!;
  }
}

class _ProviderPlus extends InheritedWidget {
  const _ProviderPlus({
    required super.child,
    this.additionalWatchers = const [],
  });

  final List<ContextWatcher<Object>> additionalWatchers;

  static _ProviderPlusElement? of(BuildContext context) {
    return context.getElementForInheritedWidgetOfExactType<_ProviderPlus>()
        as _ProviderPlusElement?;
  }

  @override
  InheritedElement createElement() => _ProviderPlusElement(this);

  @override
  bool updateShouldNotify(covariant InheritedWidget oldWidget) => false;
}

class _ProviderPlusElement extends InheritedElement {
  _ProviderPlusElement(super.widget);

  final _typedRefs = <Type, ReadOnlyRef>{};
  bool _reassembled = false;

  Ref<T> ref<T>(BuildContext context) {
    _dependOn(context as Element);

    final ref = _typedRefs[T] ??= Ref<T>();
    return ref as Ref<T>;
  }

  final _hooks = <Element, Map<int, HookState>>{};
  final _index = <Element, int>{};

  void _disposeOlds(BuildContext context) {
    final index = _index[context] ?? 0;
    final hooks = _hooks[context] ?? {};
    final disposeList = hooks.keys.where((i) => i >= index).toList();

    for (var i in disposeList) {
      final hook = hooks.remove(i)?..dispose();
      print('hook $hook disposed');
    }
  }

  int _initIndex(BuildContext context) {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (_hooks[context]!.length > _index[context]!) {
        print('disposing old hooks');
        _disposeOlds(context);
      }
      _index.remove(context);
      _reassembled = false;
    });

    return 0;
  }

  T use<T>(BuildContext context, Hook<T> hook) {
    _dependOn(context as Element);

    final index = _index[context] ??= _initIndex(context);
    final hooks = _hooks[context] ??= {};

    HookState createState() {
      print('state created');
      return hooks[index] = hook.createState()
        .._element = context
        .._hook = hook
        ..initState();
    }

    HookState updateState(HookState old) {
      print('state updated');
      return old
        .._hook = hook
        ..didUpdateHook(old.hook);
    }

    HookState resetState(HookState old) {
      print('state resetou');
      _disposeOlds(context);
      if (_reassembled) return createState();
      throw StateError('${old.hook.runtimeType} != ${hook.runtimeType}');
    }

    final state = switch (hooks[index]) {
      // When a hook was added/removed.
      var old? when old.hook.runtimeType != hook.runtimeType => resetState(old),

      // When hook and key are the same.
      var old? when Hook.canUpdate(old.hook, hook) => updateState(old),

      // When null, or key is different.
      _ => createState(),
    };

    _index[context] = index + 1;

    return state.build(context);
  }

  ReadOnlyRef<T?>? _ref<T>() => _typedRefs[T] as ReadOnlyRef<T?>?;

  Object? get<T>(BuildContext context, {bool listen = true}) {
    _dependOn(context);

    ReadOnlyRef? ref = _ref<T>();
    ref ??= _ref<Future<T>>();
    ref ??= _ref<Stream<T>>();
    ref ??= _ref<ValueListenable<T>>();

    var value = ref?.of(context);

    if (value is Future<T>) {
      return value.watchOnly(listen ? context : this, (s) => s.data);
    }
    if (value is Stream<T>) {
      return value.watchOnly(listen ? context : this, (s) => s.data);
    }
    if (value is ValueListenable<T>) {
      if (listen) value.watch(context);
      return value.value;
    }
    if (value is Listenable) {
      if (listen) value.watch(context);
    }

    if (ref == null && null is! T) {
      throw Exception(
        'Provider<$T> not found for ${context.widget.runtimeType}.',
      );
    }

    return value;
  }

  @override
  Widget build() => ContextPlus.root(child: super.build());

  void _dependOn(BuildContext context) {
    assert(context is Element);
    assert(
      context.debugDoingBuild,
      'Calling bind*() outside the build() method of a widget is not allowed.',
    );

    // Make [context] dependent on this element so that we can get notified
    // when the [context] is removed from the tree.
    context.dependOnInheritedElement(this);
  }

  @override
  void reassemble() {
    print('hot reloaded');
    super.reassemble();
    _reassembled = true;
    for (final hooks in _hooks.values) {
      for (final hook in hooks.values) {
        hook.reassemble();
      }
    }
  }

  @override
  void removeDependent(Element dependent) {
    // This method is called when the [dependent] is deactivated, but not
    // yet unmounted. The element can be reactivated during the same fame.
    // So, let's not dispose the context data immediately, but rather wait
    // until the end of the frame to see if the element is reactivated.
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!dependent.mounted) {
        _disposeContextData(dependent);
      }
    });
    super.removeDependent(dependent);
  }

  void _disposeContextData(BuildContext context) {
    _typedRefs.forEach((key, map) => map.remove(context));
    _hooks.remove(context)?.forEach((_, hook) => hook.dispose());
    _index.remove(context);
  }
}

extension ContextAPI on BuildContext {
  T read<T>() => Provider.of<T>(this, listen: false);
  T watch<T>() => Provider.of<T>(this);

  T bind<T>(
    T Function() create, {
    void Function(T value)? dispose,
    Object? key,
  }) {
    Provider<T>(
      key: ObjectKey(key),
      create: (c) => create(),
      dispose: dispose != null ? (c, v) => dispose(v) : null,
    ).bind(this);

    return watch<T>();
  }

  T use<T>(Hook<T> hook) => Hook.use(this, hook);

  /// A hook that caches a value across build.
  T useValue<T>(T value, {Object? key}) {
    return use(_ValueHook(value, key: key)).value;
  }

  /// A hook that caches a value and it's setter across build.
  (T value, ValueSetter<T> setter) useState<T>(T value, {Object? key}) {
    final state = use(_ValueHook<T>(value, key: key));
    return (state.value, state.setValue);
  }

  TickerProvider useSingleTickerProvider({Object? key}) {
    return use(_SingleTickerProviderHook(key: key));
  }

  AnimationController useAnimationController({
    Duration? duration,
    Duration? reverseDuration,
    String? debugLabel,
    double initialValue = 0,
    double lowerBound = 0,
    double upperBound = 1,
    TickerProvider? vsync,
    AnimationBehavior animationBehavior = AnimationBehavior.normal,
    Object? key,
  }) {
    vsync ??= useSingleTickerProvider();

    return use(
      _AnimationControllerHook(
        key: key,
        duration: duration,
        reverseDuration: reverseDuration,
        debugLabel: debugLabel,
        initialValue: initialValue,
        lowerBound: lowerBound,
        upperBound: upperBound,
        vsync: vsync,
        animationBehavior: animationBehavior,
      ),
    );
  }
}

@Deprecated('Use Provider instead.')
typedef ChangeNotifierProvider<T extends ChangeNotifier> = Provider<T>;

@Deprecated('Use Provider instead.')
typedef ListenableProvider<T extends Listenable> = Provider<T>;

@Deprecated('Use Provider instead.')
typedef ValueListenableProvider<T> = Provider<ValueListenable<T>>;

@Deprecated('Use Provider instead.')
typedef StreamProvider<T> = Provider<Stream<T>>;

@Deprecated('Use Provider instead.')
typedef FutureProvider<T> = Provider<Future<T>>;

typedef ChangeNotifierProxyProvider<T extends ChangeNotifier, R> = Provider<T>;

class ProxyProvider<T, R> extends ProviderWidget {
  const ProxyProvider({
    super.key,
    super.builder,
    super.child,
    required this.update,
    this.updateShouldNotify,
    this.ref,
    this.lazy,
    this.create,
    this.dispose,
  });

  final R Function(BuildContext context, T value, R? previous) update;
  final bool Function(R previous, R current)? updateShouldNotify;
  final Ref<R>? ref;
  final bool? lazy;
  final Create<R>? create;
  final void Function(BuildContext context, R value)? dispose;

  @override
  void bind(BuildContext context) {
    var ref = this.ref ?? _ProviderPlus.of(context)!.ref<R>(context);
    final previous = Provider.of<R?>(context, listen: false);

    ref.bindLazy(
      key: Provider.of<T>(context),
      context,
      () => update(
        context,
        Provider.of<T>(context),
        previous ?? create?.call(context),
      ),
      dispose: dispose != null ? (v) => dispose!(context, v) : null,
    );

    if (lazy == false) {
      ref.of(context);
    }
  }
}

abstract class Hook<R> {
  const Hook({this.key});
  final Object? key;

  static T use<T>(BuildContext context, Hook<T> hook) {
    return _ProviderPlus.of(context)!.use(context, hook);
  }

  /// A [Widget.canUpdate] implementation for [Hook] with collection equality.
  static bool canUpdate(Hook oldHook, Hook newHook) {
    return oldHook.runtimeType == newHook.runtimeType &&
        switch ((oldHook.key, newHook.key)) {
          (List a, List b) => listEquals(a, b),
          (Set a, Set b) => setEquals(a, b),
          (Map a, Map b) => mapEquals(a, b),
          (var a, var b) => a == b,
        };
  }

  HookState<R, Hook<R>> createState();
}

abstract class HookState<R, T extends Hook<R>> {
  BuildContext get context => _element!;
  Element? _element;

  T get hook => _hook!;
  T? _hook;

  @protected
  void initState() {}

  @protected
  void dispose() {}

  @protected
  void didUpdateHook(T oldHook) {}

  @protected
  void reassemble() {}

  @protected
  R build(BuildContext context);

  @protected
  void setState(VoidCallback fn) {
    fn();
    _element?.markNeedsBuild();
  }
}

class _ValueHook<T> extends Hook<_StateHookState<T>> {
  const _ValueHook(this.value, {super.key});
  final T value;

  @override
  _StateHookState<T> createState() => _StateHookState<T>();
}

extension StateSetterExtension<T> on (T, void Function(T)) {
  T get value => $1;
  set value(T value) => $2(value);
}

class _StateHookState<T> extends HookState<_StateHookState<T>, _ValueHook<T>> {
  late var value = hook.value;

  void setValue(T value) {
    setState(() => this.value = value);
  }

  @override
  _StateHookState<T> build(BuildContext context) => this;
}

class _SingleTickerProviderHook extends Hook<TickerProvider> {
  const _SingleTickerProviderHook({super.key});

  @override
  _TickerProviderHookState createState() => _TickerProviderHookState();
}

class _TickerProviderHookState
    extends HookState<TickerProvider, _SingleTickerProviderHook>
    implements TickerProvider {
  Ticker? _ticker;
  ValueListenable<bool>? _tickerModeNotifier;

  @override
  Ticker createTicker(TickerCallback onTick) {
    assert(() {
      if (_ticker == null) {
        return true;
      }
      throw FlutterError(
          '${context.widget.runtimeType} attempted to use a useSingleTickerProvider multiple times.\n'
          'A SingleTickerProviderStateMixin can only be used as a TickerProvider once. '
          'If you need multiple Ticker, consider using useSingleTickerProvider multiple times '
          'to create as many Tickers as needed.');
    }(), '');
    _ticker = Ticker(onTick, debugLabel: 'created by $context');
    _updateTickerModeNotifier();
    _updateTicker();
    return _ticker!;
  }

  @override
  void dispose() {
    assert(() {
      if (_ticker == null || !_ticker!.isActive) {
        return true;
      }
      throw FlutterError(
          'useSingleTickerProvider created a Ticker, but at the time '
          'dispose() was called on the Hook, that Ticker was still active. Tickers used '
          ' by AnimationControllers should be disposed by calling dispose() on '
          ' the AnimationController itself. Otherwise, the ticker will leak.\n');
    }(), '');
    _tickerModeNotifier?.removeListener(_updateTicker);
    _tickerModeNotifier = null;
    super.dispose();
  }

  @override
  TickerProvider build(BuildContext context) {
    _updateTickerModeNotifier();
    _updateTicker();
    return this;
  }

  void _updateTicker() {
    if (_ticker != null) {
      _ticker!.muted = !_tickerModeNotifier!.value;
    }
  }

  void _updateTickerModeNotifier() {
    final newNotifier = TickerMode.getNotifier(context);
    if (newNotifier == _tickerModeNotifier) {
      return;
    }
    _tickerModeNotifier?.removeListener(_updateTicker);
    newNotifier.addListener(_updateTicker);
    _tickerModeNotifier = newNotifier;
  }
}

class _AnimationControllerHook extends Hook<AnimationController> {
  const _AnimationControllerHook({
    this.duration,
    this.reverseDuration,
    this.debugLabel,
    required this.initialValue,
    required this.lowerBound,
    required this.upperBound,
    required this.vsync,
    required this.animationBehavior,
    super.key,
  });

  final Duration? duration;
  final Duration? reverseDuration;
  final String? debugLabel;
  final double initialValue;
  final double lowerBound;
  final double upperBound;
  final TickerProvider vsync;
  final AnimationBehavior animationBehavior;

  @override
  _AnimationControllerHookState createState() =>
      _AnimationControllerHookState();
}

class _AnimationControllerHookState
    extends HookState<AnimationController, _AnimationControllerHook> {
  late final _animationController = AnimationController(
    vsync: hook.vsync,
    duration: hook.duration,
    reverseDuration: hook.reverseDuration,
    debugLabel: hook.debugLabel,
    lowerBound: hook.lowerBound,
    upperBound: hook.upperBound,
    animationBehavior: hook.animationBehavior,
    value: hook.initialValue,
  )..addListener(() => setState(() {}));

  @override
  void didUpdateHook(_AnimationControllerHook oldHook) {
    super.didUpdateHook(oldHook);
    if (hook.vsync != oldHook.vsync) {
      _animationController.resync(hook.vsync);
    }

    if (hook.duration != oldHook.duration) {
      _animationController.duration = hook.duration;
    }

    if (hook.reverseDuration != oldHook.reverseDuration) {
      _animationController.reverseDuration = hook.reverseDuration;
    }
  }

  @override
  AnimationController build(BuildContext context) {
    return _animationController;
  }

  @override
  void dispose() {
    _animationController.dispose();
  }
}
